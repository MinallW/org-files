* Algoritmos de Ordenamiento

  Algoritmos utilizados para ordenar miembros de una lista de
  elementos de acuerdo a un parámetro. En nuestro arreglo:
  
  #+BEGIN_SRC ruby
  array [Miguel, Marcos, Alejandro, Bell, Carlos]
  #+END_SRC
  
  Si utilizamos un algoritmo de ordenamiento, queremos orden
  alfabético, nuestro arreglo se verá:
  
  #+BEGIN_SRC ruby
  array [Alejandro, Bell, Carlos, Miguel, Marcos]
  #+END_SRC

  Si nuestro arreglo fuera, números, nos gustaría ordenarlo de menor a
  mayor:

  #+BEGIN_SRC ruby
  array [67, 1, 0, 43, 12, 74, 12, 154, 0.2, 312, -1]
  #+END_SRC

  Quedará:

  #+BEGIN_SRC ruby
  array [-1, 0.2, 0, 1, 12, 12, 43, 67, 74, 154, 312]
  #+END_SRC

  ¿Por qué querría ordenar mi arreglo?, es importante. Por ejemplo,
  puede hacer que otros logaritmos sean más rápidos. Un logaritmo de
  búsqueda de algún dato dá mejor rendimiento con datos arreglados
  (depende del logaritmo)

  Cuando hablamos de algoritmos de ordenamiento, es importante tener
  algunas definiciones claras:

  - Ordenamiento 'en el Lugar' :: Un algoritmo que modifica
       directamente el arreglo. Existen algoritmos que crean nuevos
       arreglos de acuerdo a los resultados. En nuestro ejemplo de
       arriba, no creamos un nuevo arreglo, si no que 'modificamos' el
       ya existente.

  - Ordenamiento Interno y Externo :: Un algoritmo externo, es aquel
       que guarda sus resultados 'externamente'. Similar a 'en el
       lugar', pero más 'amplio'.

       Ordenamiento 'en el lugar' crea una nueva array, mientras que
       una externa puede, además de crear una nueva array, almacenarla
       externamente a la computadora donde se ejecuta el logaritmo. 

       Un ejemplo de esto es, una computadora que ejecuta el
       algoritmo, y los resultados los guarda en un Disco Duro, más no
       dentro de la computadora.

       Ordenamiento Interno se refiere a lo contrario, hablamos de que
       los resultados los guarda en la misma computadora donde se
       ejecuta el logaritmo.

  - Ordenamiento Estable :: Cuando se arregla un algoritmo, depende de
       este, se pueden obtener distintos resultados, esto claro, con
       los algoritmo inestables.

       Un algoritmo es considerado estable cuando siempre muestra el
       mismo resultado. Como ejemplo, tengo un nuevo arreglo:

       #+BEGIN_SRC ruby
	 arreglo = [
	   Miguel  A
	   Brenda  B
	   Someone  C
	   Hello  A
	   You  B
	   Nope B
	 ]
       #+END_SRC
       
       Si utilizamos un algoritmo estable, ordenandolos por su última letra, nos dará:

       #+BEGIN_SRC ruby
	 new_hash = [
	   Miguel  A
	   Hello  A
	   Brenda  B
	   You  B
	   Nope B
	   Someone C
	 ]
       #+END_SRC

       En un algoritmo inestable, podemos tener varios resultados:

       #+BEGIN_SRC ruby
	   Hello  A
	   Miguel  A
	   You  B
	   Nope B
	   Brenda  B
	   Someone C
       #+END_SRC
       
       O:

       #+BEGIN_SRC ruby
	   Miguel  A
	   Hello  A
	   You  B
	   Brenda  B
	   Nope B
	   Someone C
       #+END_SRC
       
       El punto es, que el algoritmo puede que cambie algunos
       elementos ya que, la letra es la misma. Un Algoritmo estable
       siempre nos dará el mismo resultado.

  - Complejidad de un logaritmo :: La complejidad de un logaritmo está
       conectada con su runtime (cuanto tiempo tarda el logaritmo en
       terminar). Para esto utilizamos fórmulas que nos ayudan a
       calcular el rendimiento de un algoritmo. 

       Una manera de calcular el rendimiento es con la Notación Big-O,
       nos ayudará a ver el runtime depende a los datos que
       pongamos. Por ejemplo, un logaritmo O(1) se refiere a que el
       logaritmo siempre se tardará lo mismo, independientemente de
       cuantos datos pondremos.
       
       O(n) se refiere entonces, a que lo que tarde el logaritmo
       dependerá de los datos que pongamos, mientras más datos usemos,
       más se tardará el logaritmo en completarse. Hay que mencionar,
       que la notación Big-O se refiere al peor caso posible para un
       algoritmo. Por ejemplo, que un logaritmo busque un número del 1
       al 100 y el número sea 99, por lo que tiene que ir de número en
       númer comparando. 

       También puede usarse para calcular otro tipo de casos además de
       el peor, un caso regular (un logaritmo busca del 1 al 100 el
       número 50) o un caso 'fácil' (del 1 al 100 búsca el número 20)
       para un logaritmo. 

  - Algoritmo de dividir y conquistar :: Aquellos algoritmos que
       ordenan siguiendo 3 pasos:

    - Dividir :: Separa la base de datos en trozos más pequeños
    - Conquistar :: Resuelve los problemas de los trozos más pequeños
    - Combinar :: Combina los trozos resueltos y chequea

	Un algoritmo que, al presentarse un problema, lo separa y crea
        subproblemas, los cuales resolverá para luego llegar a el
        resultado al problema completo.

  Una vez entendido estas definiciones, presentaremos los algoritmos
  de ordenamiento en sí, todos los ejemplos se harán con Arrays:

** Ordenamiento por Selección

   Este algoritmo busca el elemento más pequeño en un arreglo,
   y la pone al principio, luego hace lo mismo con el siguiente menor
   y lo pone en la segunda posición. Todo proceso lo hace 'en el
   lugar', además de no ser estable. De acuerdo a la notación Big-O,
   su complejidad es de O(n^2):


   #+BEGIN_SRC ruby :results output
     some_array = [23, 51, 71, 12, 43, 0, 42, -1, 0.25, 1, 22, 19, 1002]
     new_array = []

     for i in 0...some_array.length
       new_array.push(some_array.min)
       some_array.delete(some_array.min)

     end
     puts new_array

   #+END_SRC

** Ordenamiento Burbuja

   Este algoritmo es estable y hace toda operación 'en el
   lugar'. Compara un elemento con su vecino (de la derecha) y, si el
   elemento es menor, los cambia de lugar. Seguirá hasta que no se
   haya hecho ningún cambio. Por ejemplo, tenemos un arreglo:

   #+BEGIN_SRC ruby
   arreglo = [1, 0, 4, 3, 2, 6, 7, 8]
   #+END_SRC

   Bubble sort, hará un primer recorrido al arreglo, siguiendo la
   regla de, si el elemento es mayor a su vecino, cambiarlos de lugar.

   Siguiendo la regla, cambiará 1 y 0, 4 y 3 y 4 y 2 de lugar:

   #+BEGIN_SRC ruby
   [0, 1, 3, 2, 4, 6, 7, 8]
   #+END_SRC

   Debido a que hubo 'cambios', el algoritmo hará un nuevo recorrido,
   esta vez solo cambiando 3 y 2

   #+BEGIN_SRC ruby
   [0, 1, 2, 3, 4, 6, 7, 8]
   #+END_SRC
   
   Hubieron cambios, por lo que hara un tercer recorrido, sin embargo,
   sin hacer ningún cambio:

   #+BEGIN_SRC ruby
   [0, 1, 2, 3, 4, 6, 7, 8] # Ya está arreglado
   #+END_SRC

   Sin, el algoritmo no se volverá a ejecutar. Su representación en
   código sería:

   #+BEGIN_SRC ruby :results output

     some_array = [23, 51, 71, 12, 43, 0, 42, -1, 0.25, 1, 22, 19, 1002]

     for i in 0...some_array.length
       for j in i+1...some_array.length
	 if some_array[i] > some_array[j]
	   some_array[i], some_array[j] = some_array[j], some_array[i]
	 end
       end
     end
     puts some_array

 #+END_SRC

** Ordenamiento Rápido

   No es un algoritmo estable, es 'en el lugar' y es de tipo 'divide y
   conquista'. Ordena un arreglo comparandolo con un 'pivote', el
   pivote es nuestro punto de referencia, su representación en código sería:
   
   #+BEGIN_SRC ruby :results output

     some_array = [10, 80, 30, 90, 40, 50, 70]
     pivot = some_array.last
     smaller = -1
     for i in 0...some_array.length
       if pivot > some_array[i]
	 smaller += 1
	 some_array[i], some_array[smaller] = some_array[smaller], some_array[i]
       else
	 some_array[i], some_array[some_array.length-1] = some_array[some_array.length-1], some_array[i]
       end
     end
     puts some_array

   #+END_SRC

   ¿Qué hace este algoritmo a nuestro arreglo?. Dado nuestro arreglo:

   #+BEGIN_SRC 
   [10, 80, 30, 90, 40, 50, 70]
   #+END_SRC
   Nuestro pivote es 70, va preguntando a nuestro arreglo sus
   contenidos, y los compara, es 70 menor que 10?, no hagas nada. Es
   80 menor que 70, ¿no?, haz un cambio.
   #+BEGIN_SRC 
   [10, 70, 30, 90, 40, 50, 80]
   #+END_SRC
   ¿Está 70 en una posición menor a 30?, haz un cambio.
   #+BEGIN_SRC 
   [10, 30, 70, 90, 40, 50, 80]
   #+END_SRC
   Así sucesivamente, nuestro algoritmo hace comparaciones con nuestro
   pivote (70) como referencia, y de acuerdo a ellos, ordena nuestro
   arreglo, hasta que quede:
   #+BEGIN_SRC 
   [10, 30, 40, 50, 70, 80, 90]
   #+END_SRC

** Ordenamiento por Fusión

   Es un algoritmo estable, no se ejecuta 'en el lugar' y es de tipo
   dividir y conquistar. Separa nuestro arreglo en nuevos arreglos,
   ordenas los nuevos arreglos, los úne y los vuelve a arreglar hasta
   dar con el resultado, es mejor representado en una imagen:

   [[https://www.geeksforgeeks.org/wp-content/uploads/Merge-Sort-Tutorial.png]]

   Tiene un complejidad de O(n (log n)), la mayoría de los algoritmos
   tipo 'dividir y conquistar' tienen esta complejidad. Su
   representación en código es:

   #+BEGIN_SRC ruby :results output

     some_array = [23, 51, 71, 12, 43, 0, 42, -1, 0.25, 1, 22, 19, 1002]
     final_array= []
     separate = some_array.length / 2

     first_array = some_array.take(separate)
     second_array = some_array.drop(separate)

     first_array.each do
       final_array.push(first_array.min)
       first_array.delete(first_array.min)
     end

     second_array.each do
       final_array.push(second_array.min)
       second_array.delete(second_array.min)
     end

     for i in 0...final_array.length
       for j in i+1...final_array.length
	 if final_array[i]>final_array[j]
	   change=final_array[i]
	   final_array[i]=final_array[j]
	   final_array[j]=change
	 end
       end
     end

     puts final_array


   #+END_SRC

   #+RESULTS:
   : -1
   : 0
   : 0.25
   : 1
   : 12
   : 19
   : 23

** Ordenamiento por Inserción

   Es un algoritmo estable y 'en el lugar'. Escanea un elemento y, si
   es menor, lo pone al principio de el arreglo (comparándolo con los
   primeros para ver su posición).

   [[https://media.geeksforgeeks.org/wp-content/uploads/insertionsort.png]]

   Tiene una complejidad de O(n^2), aquellos algoritmos cuyo código
   suele contener dos loops (for) tienen esta complejidad, su
   representación en código es:
   
      #+BEGIN_SRC ruby :results output

     some_array = [23, 51, 71, 12, 43, 0, 42, -1, 0.25, 1, 22, 19, 1002]

     for i in 0...some_array.length
       for j in i+1...some_array.length
	 if some_array[i]>some_array[j]
	   change=some_array[i]
	   some_array[i]=some_array[j]
	   some_array[j]=change
	 end
       end
     end
     puts some_array

   #+END_SRC



   
