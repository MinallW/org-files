#+TITLE: Ruby

Recopilation of important ruby syntaxes

* Methods

- print :: print something
- puts :: print something and newline
- gets :: get input from user

* Good To Know

For embedding something into a string, use #{$variable}
For comments, use '#'
A class is a blueprint from which individual objects are constructed.
An object is something with characteristics and actions
Is there's a /initialize/ method, it's automatically called when an object is created.
For inspecting an object, use /object.inspect/.

To indicate a /subclass/ or descendant of another class, use '<'

#+BEGIN_SRC ruby
class Child < Parent
end
#+END_SRC

Child inherits from Parent

We can use the /super/ keyword in order to initalize some variable attributes by
calling the /superclass/ of the object we're in:

#+BEGIN_SRC ruby
super( aName, aDescription )
#+END_SRC

For accessing or writing into a variable's object, we should use accessors,
being it creating the methods itself:

#+BEGIN_SRC ruby
def get_name
  return @name
end
def set_name(aName)
  @name = aName
end
#+END_SRC

Or use attributes:

#+BEGIN_SRC ruby
attr_reader :description
attr_writer :description
# Or just
attr_accessor :description
#+END_SRC

Or create functions but maintaining the name:

#+BEGIN_SRC ruby
def description
  return @description
end
def description=( aDescription )
  @description = aDescription
end
#+END_SRC

Creating methods allow us to add more steps and have more control.

For more values at once, there are some syntaxes:

#+BEGIN_SRC ruby
attr_reader :name, :description
attr_writer(:name, :description)
attr_accessor(:value, :id, :owner)
#+END_SRC

There are several ways to represent *loops*:

#+BEGIN_SRC ruby
for i in [1,2,3] do
  puts (i)
end
# Is the same as
[1,2,3].each do |i|
  puts( i )
end

# or use different syntaxees such as:

for i in [1, "two", [3,4,5]] do puts( x ) end

# Or

[1, "two", [3,4,5]].each do |x| puts( x ) end

# While Loops

while tired
  sleep
end

# Or

sleep while tired

# For more complex syntax

begin
  sleep
  snore
end while tired

# Or with until, can be though of as 'while not' loop. Its syntax and options are the same as with while.

sleep until tired
#+END_SRC

With conditionals, we have these syntaxes:

#+BEGIN_SRC ruby
if x == 1
  puts( 'Ok' )
end
# Or

if x == 1 then puts ( 'Ok' ) end # then is mandatory in this syntax

# Or use symbols

x == 10 ? puts ("It's 10") : puts ("It's some other number")

# For a more complex syntax

(aDay == 'Saturday') or aDay == 'Sunday' ?
                          daytype = 'weekend' :
                          daytype = 'weekday'

# Other syntaxes include

puts( "somevar = #{somevar}" ) if DEBUG

# For more control, we can use case

case(i)
when 1 then puts ("It's monday")
when 2 then puts ("It's tuesday")
when 3..7 then puts ("Ok")
else puts ("Not a real day")
end

# For a multi trigger function or more syntaxes, we can use:

case (i+1) # Can accept different values
when 1, 'Monday', 'Mon' then puts ('Monday')
when 3,4,5 then break
end
#+END_SRC

We can access constants of a module like so:

#+BEGIN_SRC ruby
module MyModule
  GOODMOOD = "happy"
end

puts(MyModule::GOODMOOD)
#+END_SRC

For including a model, into a class, use /include/. We can also include files
/./textmod.rb/. It returns true if the module was succesfully added.

Methods group together related methods, constants and classes within a named
scope.

Ruby has a File library for dealing with files I/O.

A simple syntax for exceptions is:

#+BEGIN_SRC ruby
startdir = Dir.getwd # We use Dir class for knowing the directory we're in

begin
  Dir.chdir( "X:\\" )
  puts( `dir` )
rescue Exception => e # We declare the exception to a variable named 'e'
  puts e.class
  puts e # May run if the directory doesn't exist or couldn't be loaded
else
  puts "I will run if no exception appears"
ensure # Will always run
  Dir.chdir( startdir ) # We return to the directory of the beginning
end
#+END_SRC

yield calls a lambda, for example:

#+BEGIN_SRC ruby
def make_salad
  yield "lettuce"
  yield "carrots"
  yield "olive oil"
end

make_salad { |ingredient| puts
  "Adding #{ingredient} to salad!"}
#+END_SRC

If make_salad doesn't exist, yield will raise an error.

Threads make your Ruby programs do multiple things at the same time. Things
like:

- Reading multiple files
- Handlind multiple web requests
- Making multiple API connections

There are several variables such as:

- with global scope :: with '$' in its beginning
- define attributes of a single object :: starting with '@'
- define attr of several objects :: Starting with '@@'
- Local scope :: start with '_' or lowercase letter
- Constants :: Starting with an uppercase letter
- Special variables or pseudo-variables ::

  - self :: The receiver object of the current method

  - true :: true state

  - false ::

  - nil ::

  - __FILE__ :: The name of the current source file.

  - __LINE__ :: The current line nuber
