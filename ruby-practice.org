** Action View

   In Rails, web requeests are handled by Action Controller and Action
   View, the first communicates with the database and performs CRUD
   operations, while the latter compiles and shows the response.

   Action view uses templates of Embedded Ruby (erb), where one can
   write HTML. We also have some helper classes that provide forms,
   dates and strings, or the ability to add new helpers.

   Some features of Action View are tied to Active Record, but the
   first is indepenedent, it's a Ruby library.
   
*** Using Action View with Rails
    
    Every controller has a directoy associated in the app/views
    directory, holding template files that make up the views
    associated with that controller.
    
    We can create a new resource using the scaffold generator:

    #+BEGIN_SRC bash
    rails generate scaffold article
    #+END_SRC
    
    The views generated share their name with the associated
    controller action.

**** Templates, Partials, and Layouts

     The final HTML output is a composition of three Rails elements:
     Templates, Partials and Layouts.

***** Templates

      Action view templates can be, erb or .builder, in the latter the
      library Builder::XmlMarkup is used.

****** ERB

       Ruby code can be embedded in HTML, with the tags '<% %>' and
       <%= %>, the first is used then you don't return anything, such
       as conditions, loops or blocks, when you want output, use the
       latter.

       In this example, we create a loop and then return a value with
       <%= %> tags:

       #+BEGIN_SRC ruby
	 <h1>Names of all the people</h1>
	 <% @people.each do |person| %>
	   Name: <%= person.name %><br>
	 <% end %>
       #+END_SRC
    
       Regular output functions such as puts won't be rendered to the
       view with ERB templates, so they aren't used.

****** Builder

       These templates are a more programmatic alternative to
       ERB. They're useful to generate XML content. An XmlMarkup
       object named xml is automatically made available to templates
       with a .builder extension.

****** Jbuilder
       
       Produces JSON instead of XML, we should add gem 'jbuilder' to
       the Gemfile. Templates with a .jbuilder extension.

****** Template Caching

       Rails will compile each template to a method in order to render
       it. When you alter a template Rails will check the file's
       modification time and recompile it in development mode.

***** Partials

      Used for breaking the rendering process into more manageable
      chunks. With partials, you can extract pieces of code from your
      template to separate files and also reuse them throughout your templates.

****** Naming Partials

       To render a partial as part of a view, we use the render
       methods within the view:

       #+BEGIN_SRC ruby
       <%= render "menu" %>
       #+END_SRC
       
       This renders a file name _menu.html.erb at that point within
       the view that is being rendered. partials are named with a
       leading underscore to distinguish them from regular views.
       
** What is Active Record?

   Represents the M in the MVC model, the layer responsible for
   representing business data and logic. It facilitates the creation
   and use of business objects whose data requires persistent storage
   to a database. 

   It's an implementation of the Active Record Pattern which itself is
   a description of an Object Relational Mapping system.

*** The Active Record Pattern

    A pattern, can be defined as a common solution programmers apply
    to a problem, in this case, the Active Record Pattern makes sure
    that working with OO languages and Databases is done easily.

    Provides CRUD operations and equivalents on databases, for example

    | Ruby       | DataBase                           |
    |------------+------------------------------------|
    | Classes    | Tables                             |
    | Objects    | Records (Rows in a table)          |
    | Attributes | Record Values (Columns in a table) |

    [[http://researchhubs.com/uploads/active-record-design-pattern-1.png]]

    Basically, we store data in a database form, ActiveRecord maps
    objects to a relational database.

**** Active Record in Ruby

     Used to save data that can be recalled for later use, in a form
     of databases where you can perform CRUD operations. It's a Ruby
     Library, you can use it to work with SQL Databases like MySQL and
     Postgres. We have the following features:

     - A single Ruby object maps to a database table
     - columns are accessed by methods.
     - methods for CRUD operations
     - A DSL for easily constructing SQL queries in Ruby.
     - Establish a connection to a database
     - Create database tables
     - Specify association between tables that correspond to
       associations between the Ruby classes.
     - Establish an Object Relational Mapping (ORM) between Ruby
       classes/objects/attributes and the tables/rows/columns in the
       underlying database.

     In Rails, we have different methods that make this work for us,
     specifically working with the database.yml file.

    
*** Usage in Rails

    By default, Active Record uses some naming conventions to find out
    how the mapping between models and databases tables should be
    created. Rails will pluralize your class names to find the
    respective database table. So, for a class Book, you shoul have a
    database table called books. It also depends in two words
    separated by underscores. For example:

    | Model Class | Database Table |
    |-------------+----------------|
    | BooksClub   | books_clubs    |
    
    To create Active Record models, we'll add our class as a subclass
    of Aplplication Record:

    #+BEGIN_SRC ruby
    class Product < ApplicationRecord
    end
    #+END_SRC
    
    This will create a Product model, mapped to a products table at
    the database. We'll also have the ability to map the columns of
    each row in that table with the attributes of the instances of
    your model. Suppose that the products table was created using an
    SQL statements like:

    #+BEGIN_SRC sql
      CREATE TABLE produts (
	     id int(11) NOT NULL auto_increment,
	     name varchar(255)
	     PRIMARY KEY (id)
      )
    #+END_SRC

    This schema declares a table with two columns: id and name. Each
    row of this table represents a certain product with these two
    parameters. This, you would be able to write code like the
    following:
    
    #+BEGIN_SRC ruby
      p = Product.new
      p.name = "Some Book"
      puts p.name # "Some Book"
    #+END_SRC

* Naming conventions

  Ruby uses name conventions in order to identify the purpose of something,
  whether it's a constant, a variable or something else.

* Ruby NameSpaces

  Used to access an item, on a model, for example> Dsa::Something tells, access
  the Something class inside the Dsa model.
